cargo : warning: unused manifest key: profile.release.wasm
At D:\AI\去中心化训练\build_check.ps1:3 char:16
+ $buildOutput = cargo build 2>&1
+                ~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (warning: unused...le.release.wasm:String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
   Compiling williw v0.1.1 (D:\AI\去中心化训练)
error[E0252]: the name `GenericArray` is defined multiple times
  --> src\crypto\zero_copy.rs:15:5
   |
13 | use cipher::generic_array::GenericArray;
   |     ----------------------------------- previous import of the type `GenericArray` here
14 | use block_modes::block_padding::Pkcs7;
15 | use block_modes::cipher::generic_array::GenericArray;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GenericArray` reimported here
   |
   = note: `GenericArray` must be defined only once in the type namespace of this module

error[E0432]: unresolved imports `block_modes::BlockModeEncrypt`, `block_modes::BlockModeDecrypt`
 --> src\privacy\crypto\algorithms.rs:9:35
  |
9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
  |                                   ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^ no `BlockModeDecrypt` in the root
  |                                   |
  |                                   no `BlockModeEncrypt` in the root
  |                                   help: a similar name exists in the module: `BlockModeError`

error[E0432]: unresolved imports `cipher::BlockMode`, `cipher::BlockModeDecrypt`, `cipher::BlockModeEncrypt`
  --> src\crypto\zero_copy.rs:12:14
   |
12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
   |              ^^^^^^^^^  ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^ no `BlockModeEncrypt` in the root
   |              |          |
   |              |          no `BlockModeDecrypt` in the root
   |              no `BlockMode` in the root
   |
   = help: consider importing this trait instead:
           block_modes::BlockMode
help: a similar name exists in the module
   |
12 - use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
12 + use cipher::{BlockMode, BlockDecrypt, BlockModeEncrypt};
   |
help: a similar name exists in the module
   |
12 - use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
12 + use cipher::{BlockMode, BlockModeDecrypt, BlockEncrypt};
   |

error[E0412]: cannot find type `Cbc` in this scope
  --> src\crypto\zero_copy.rs:18:18
   |
18 | type Aes256Cbc = Cbc<Aes256, Pkcs7>;
   |                  ^^^ not found in this scope
   |
help: consider importing this struct
   |
 5 + use block_modes::Cbc;
   |

warning: unused import: `block_modes::cipher::generic_array::GenericArray`
  --> src\privacy\crypto\algorithms.rs:11:5
   |
11 | use block_modes::cipher::generic_array::GenericArray;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `VerifyingKey as SolPublicKey`
 --> src\crypto\base.rs:6:47
  |
6 | use ed25519_dalek::{SigningKey as SolKeypair, VerifyingKey as SolPublicKey,
  |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `EncryptionAlgorithm`
 --> src\crypto\selective.rs:9:13
  |
9 | use super::{EncryptionAlgorithm, HighPerformanceCrypto, HighPerformanceCryptoConfig, PrivacyLevel};
  |             ^^^^^^^^^^^^^^^^^^^

warning: unused import: `cipher::generic_array::GenericArray`
  --> src\crypto\zero_copy.rs:13:5
   |
13 | use cipher::generic_array::GenericArray;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `block_modes::cipher::generic_array::GenericArray`
  --> src\crypto\zero_copy.rs:15:5
   |
15 | use block_modes::cipher::generic_array::GenericArray;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `batch::*`
  --> src\crypto\mod.rs:21:9
   |
21 | pub use batch::*;
   |         ^^^^^^^^

warning: unused import: `rand::Rng`
  --> src\comms\handle.rs:10:5
   |
10 | use rand::Rng;
   |     ^^^^^^^^^

warning: unused import: `anyhow`
 --> src\comms\routing.rs:9:14
  |
9 | use anyhow::{anyhow, Result};
  |              ^^^^^^

warning: use of deprecated function `rand::thread_rng`: Renamed to `rng`
  --> src\privacy\crypto\algorithms.rs:36:15
   |
36 |         rand::thread_rng().fill_bytes(&mut key);
   |               ^^^^^^^^^^
   |
   = note: `#[warn(deprecated)]` on by default

warning: use of deprecated function `rand::thread_rng`: Renamed to `rng`
   --> src\privacy\crypto\algorithms.rs:103:15
    |
103 |         rand::thread_rng().fill_bytes(&mut nonce);
    |               ^^^^^^^^^^

warning: use of deprecated function `rand::thread_rng`: Renamed to `rng`
   --> src\privacy\crypto\algorithms.rs:147:15
    |
147 |         rand::thread_rng().fill_bytes(&mut iv);
    |               ^^^^^^^^^^

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> src\comms\handle.rs:106:26
    |
106 |         let secret_key = iroh::SecretKey::generate();
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&mut _` is missing
    |
note: associated function defined here
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\iroh-base-0.95.1\src\key.rs:284:12
    |
284 |     pub fn generate<R: CryptoRng + ?Sized>(csprng: &mut R) -> Self {
    |            ^^^^^^^^
help: provide the argument
    |
106 |         let secret_key = iroh::SecretKey::generate(/* csprng */);
    |                                                    ++++++++++++

error[E0599]: no method named `bind_addr` found for struct `iroh::endpoint::Builder` in the current scope
   --> src\comms\handle.rs:111:14
    |
108 |           let endpoint = Endpoint::builder()
    |  ________________________-
109 | |             .secret_key(secret_key)
110 | |             .alpns(vec![b"ggb-iroh/1".to_vec()])
111 | |             .bind_addr(bind_addr_v4.into())
    | |_____________-^^^^^^^^^
    |
help: there is a method `bind_addr_v4` with a similar name
    |
111 |             .bind_addr_v4(bind_addr_v4.into())
    |                       +++

warning: unused variable: `quic`
   --> src\comms\handle.rs:370:21
    |
370 |         if let Some(quic) = &self.quic {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_quic`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockEncrypt` is not satisfied
   --> src\privacy\crypto\algorithms.rs:149:22
    |
149 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key.as_bytes(), &iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockEncrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:57:1
    |
 57 | pub trait BlockEncrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:33
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                 ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockDecrypt` is not satisfied
   --> src\privacy\crypto\algorithms.rs:149:22
    |
149 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key.as_bytes(), &iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockDecrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:94:1
    |
 94 | pub trait BlockDecrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:48
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                                ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0599]: the function or associated item `new_from_slices` exists for struct `Cbc<Aes256, Pkcs7>`, but its trait b
ounds were not satisfied
   --> src\privacy\crypto\algorithms.rs:149:44
    |
149 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key.as_bytes(), &iv)
    |                                            ^^^^^^^^^^^^^^^ function or associated item cannot be called on `Cbc<A
es256, Pkcs7>` due to unsatisfied trait bounds
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- doesn't satisfy `Aes256: block_modes::ciph
er::BlockCipher`, `Aes256: block_modes::cipher::BlockDecrypt` or `Aes256: block_modes::cipher::BlockEncrypt`
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:1
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    | ------------------------------------------------------------------------ doesn't satisfy `Cbc<Aes256, Pkcs7>: Blo
ckMode<Aes256, Pkcs7>`
    |
    = note: the following trait bounds were not satisfied:
            `Aes256: block_modes::cipher::BlockCipher`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockEncrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockDecrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockEncrypt` is not satisfied
   --> src\privacy\crypto\algorithms.rs:173:22
    |
173 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key.as_bytes(), iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockEncrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:57:1
    |
 57 | pub trait BlockEncrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:33
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                 ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockDecrypt` is not satisfied
   --> src\privacy\crypto\algorithms.rs:173:22
    |
173 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key.as_bytes(), iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockDecrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:94:1
    |
 94 | pub trait BlockDecrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:48
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                                ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0599]: the function or associated item `new_from_slices` exists for struct `Cbc<Aes256, Pkcs7>`, but its trait b
ounds were not satisfied
   --> src\privacy\crypto\algorithms.rs:173:44
    |
173 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key.as_bytes(), iv)
    |                                            ^^^^^^^^^^^^^^^ function or associated item cannot be called on `Cbc<A
es256, Pkcs7>` due to unsatisfied trait bounds
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- doesn't satisfy `Aes256: block_modes::ciph
er::BlockCipher`, `Aes256: block_modes::cipher::BlockDecrypt` or `Aes256: block_modes::cipher::BlockEncrypt`
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:1
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    | ------------------------------------------------------------------------ doesn't satisfy `Cbc<Aes256, Pkcs7>: Blo
ckMode<Aes256, Pkcs7>`
    |
    = note: the following trait bounds were not satisfied:
            `Aes256: block_modes::cipher::BlockCipher`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockEncrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockDecrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`

error[E0308]: mismatched types
   --> src\crypto\base.rs:170:44
    |
170 |                     SolKeypair::from_bytes(&arr[..32]).map_err(|e| anyhow!("sol key error: {e}"))?
    |                     ---------------------- ^^^^^^^^^^ expected `&[u8; 32]`, found `&[u8]`
    |                     |
    |                     arguments to this function are incorrect
    |
    = note: expected reference `&[u8; 32]`
               found reference `&[u8]`
note: associated function defined here
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\ed25519-dalek-2.2.0\src\signing.rs:104:12
    |
104 |     pub fn from_bytes(secret_key: &SecretKey) -> Self {
    |            ^^^^^^^^^^

error[E0599]: no method named `map_err` found for struct `ed25519_dalek::SigningKey` in the current scope
   --> src\crypto\base.rs:170:56
    |
170 |                     SolKeypair::from_bytes(&arr[..32]).map_err(|e| anyhow!("sol key error: {e}"))?
    |                                                        ^^^^^^^ method not found in `ed25519_dalek::SigningKey`

error[E0599]: no method named `map_err` found for struct `ed25519_dalek::SigningKey` in the current scope
   --> src\crypto\base.rs:227:43
    |
227 |     SolKeypair::from_bytes(&secret_bytes).map_err(|e| anyhow!("sol key error: {e}"))
    |                                           ^^^^^^^ method not found in `ed25519_dalek::SigningKey`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockEncrypt` is not satisfied
   --> src\crypto\high_performance.rs:198:22
    |
198 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key, &iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockEncrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:57:1
    |
 57 | pub trait BlockEncrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:33
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                 ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockDecrypt` is not satisfied
   --> src\crypto\high_performance.rs:198:22
    |
198 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key, &iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockDecrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:94:1
    |
 94 | pub trait BlockDecrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:48
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                                ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0599]: the function or associated item `new_from_slices` exists for struct `Cbc<Aes256, Pkcs7>`, but its trait b
ounds were not satisfied
   --> src\crypto\high_performance.rs:198:44
    |
198 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key, &iv)
    |                                            ^^^^^^^^^^^^^^^ function or associated item cannot be called on `Cbc<A
es256, Pkcs7>` due to unsatisfied trait bounds
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- doesn't satisfy `Aes256: block_modes::ciph
er::BlockCipher`, `Aes256: block_modes::cipher::BlockDecrypt` or `Aes256: block_modes::cipher::BlockEncrypt`
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:1
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    | ------------------------------------------------------------------------ doesn't satisfy `Cbc<Aes256, Pkcs7>: Blo
ckMode<Aes256, Pkcs7>`
    |
    = note: the following trait bounds were not satisfied:
            `Aes256: block_modes::cipher::BlockCipher`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockEncrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockDecrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockEncrypt` is not satisfied
   --> src\crypto\high_performance.rs:206:22
    |
206 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key, &iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockEncrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:57:1
    |
 57 | pub trait BlockEncrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:33
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                 ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0277]: the trait bound `Aes256: block_modes::cipher::BlockDecrypt` is not satisfied
   --> src\crypto\high_performance.rs:206:22
    |
206 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key, &iv)
    |                      ^^^^^^^^^^^^^^^^^^^^ the trait `block_modes::cipher::BlockDecrypt` is not implemented for `A
es256`
    |
note: there are multiple different versions of crate `cipher` in the dependency graph
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.3.0\src\block.rs:94:1
    |
 94 | pub trait BlockDecrypt: BlockCipher {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this is the required trait
    |
   ::: src\privacy\crypto\algorithms.rs:9:5
    |
  9 | use block_modes::{Cbc, BlockMode, BlockModeEncrypt, BlockModeDecrypt};
    |     ----------- one version of crate `cipher` used here, as a dependency of crate `block_modes`
    |
   ::: src\crypto\zero_copy.rs:12:5
    |
 12 | use cipher::{BlockMode, BlockModeDecrypt, BlockModeEncrypt};
    |     ------ one version of crate `cipher` used here, as a direct dependency of the current crate
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- this type doesn't implement the required t
rait
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\cipher-0.4.4\src\block.rs:26:1
    |
 26 | pub trait BlockCipher: BlockSizeUser {}
    | ------------------------------------ this is the found trait
    = help: you can use `cargo tree` to explore your dependency tree
note: required by a bound in `Cbc`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:48
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    |                                                ^^^^^^^^^^^^ required by this bound in `Cbc`

error[E0599]: the function or associated item `new_from_slices` exists for struct `Cbc<Aes256, Pkcs7>`, but its trait b
ounds were not satisfied
   --> src\crypto\high_performance.rs:206:44
    |
206 |         let cipher = Cbc::<Aes256, Pkcs7>::new_from_slices(key, &iv)
    |                                            ^^^^^^^^^^^^^^^ function or associated item cannot be called on `Cbc<A
es256, Pkcs7>` due to unsatisfied trait bounds
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aes-0.8.4\src\autodetect.rs:430:1
    |
430 | define_aes_impl!(Aes256, Aes256Enc, Aes256Dec, aes256, U32, "AES-256");
    | ---------------------------------------------------------------------- doesn't satisfy `Aes256: block_modes::ciph
er::BlockCipher`, `Aes256: block_modes::cipher::BlockDecrypt` or `Aes256: block_modes::cipher::BlockEncrypt`
    |
   ::: C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\block-modes-0.8.1\src\cbc.rs:12:1
    |
 12 | pub struct Cbc<C: BlockCipher + BlockEncrypt + BlockDecrypt, P: Padding> {
    | ------------------------------------------------------------------------ doesn't satisfy `Cbc<Aes256, Pkcs7>: Blo
ckMode<Aes256, Pkcs7>`
    |
    = note: the following trait bounds were not satisfied:
            `Aes256: block_modes::cipher::BlockCipher`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockEncrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`
            `Aes256: block_modes::cipher::BlockDecrypt`
            which is required by `Cbc<Aes256, Pkcs7>: BlockMode<Aes256, Pkcs7>`

error[E0277]: the trait bound `Payload<'_, '_>: From<&mut [u8]>` is not satisfied
   --> src\crypto\zero_copy.rs:93:47
    |
 93 |         let encrypted = cipher.encrypt(nonce, data)
    |                                -------        ^^^^ the trait `From<&mut [u8]>` is not implemented for `Payload<'_
, '_>`
    |                                |
    |                                required by a bound introduced by this call
    |
    = help: the trait `From<&mut _>` is not implemented for `Payload<'_, '_>`
            but trait `From<&_>` is implemented for it
    = note: required for `&mut [u8]` to implement `Into<Payload<'_, '_>>`
note: required by a bound in `chacha20poly1305::aead::Aead::encrypt`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aead-0.5.2\src\lib.rs:194:25
    |
191 |     fn encrypt<'msg, 'aad>(
    |        ------- required by a bound in this associated function
...
194 |         plaintext: impl Into<Payload<'msg, 'aad>>,
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Aead::encrypt`

error[E0277]: the trait bound `Payload<'_, '_>: From<&mut [u8]>` is not satisfied
   --> src\crypto\zero_copy.rs:108:47
    |
108 |         let decrypted = cipher.decrypt(nonce, data)
    |                                -------        ^^^^ the trait `From<&mut [u8]>` is not implemented for `Payload<'_
, '_>`
    |                                |
    |                                required by a bound introduced by this call
    |
    = help: the trait `From<&mut _>` is not implemented for `Payload<'_, '_>`
            but trait `From<&_>` is implemented for it
    = note: required for `&mut [u8]` to implement `Into<Payload<'_, '_>>`
note: required by a bound in `chacha20poly1305::aead::Aead::decrypt`
   --> C:\Users\Mechrevo\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\aead-0.5.2\src\lib.rs:217:26
    |
214 |     fn decrypt<'msg, 'aad>(
    |        ------- required by a bound in this associated function
...
217 |         ciphertext: impl Into<Payload<'msg, 'aad>>,
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Aead::decrypt`

warning: unused import: `Signer`
 --> src\crypto\base.rs:9:17
  |
9 |     signature::{Signer as EthSigner, Verifier as EthVerifier},
  |                 ^^^^^^

warning: unused import: `Verifier`
 --> src\crypto\base.rs:9:38
  |
9 |     signature::{Signer as EthSigner, Verifier as EthVerifier},
  |                                      ^^^^^^^^

warning: unused variable: `encrypted`
   --> src\privacy\crypto\algorithms.rs:214:23
    |
214 |     fn decrypt(&self, encrypted: &EncryptedData, key: &CryptoKey) -> Result<Vec<u8>> {
    |                       ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_encrypted`

warning: unused variable: `key`
   --> src\privacy\crypto\algorithms.rs:214:50
    |
214 |     fn decrypt(&self, encrypted: &EncryptedData, key: &CryptoKey) -> Result<Vec<u8>> {
    |                                                  ^^^ help: if this is intentional, prefix it with an underscore: 
`_key`

warning: unused variable: `data_size`
   --> src\crypto\high_performance.rs:250:60
    |
250 |     fn update_performance_stats(&self, duration: Duration, data_size: usize) {
    |                                                            ^^^^^^^^^ help: if this is intentional, prefix it with
 an underscore: `_data_size`

warning: unused variable: `data`
   --> src\crypto\zero_copy.rs:152:39
    |
152 |     fn encrypt_blake3_in_place(&self, data: &mut [u8], key: &[u8]) -> Result<()> {
    |                                       ^^^^ help: if this is intentional, prefix it with an underscore: `_data`

warning: unused variable: `key`
   --> src\crypto\zero_copy.rs:152:56
    |
152 |     fn encrypt_blake3_in_place(&self, data: &mut [u8], key: &[u8]) -> Result<()> {
    |                                                        ^^^ help: if this is intentional, prefix it with an unders
core: `_key`

warning: unused variable: `latency`
   --> src\comms\routing.rs:341:38
    |
341 |     pub fn update_performance(&self, latency: f32, bandwidth: f32, packet_loss: f32) {
    |                                      ^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
341 |     pub fn update_performance(&self, _latency: f32, bandwidth: f32, packet_loss: f32) {
    |                                      +
help: you might have meant to pattern match on the similarly named constant `EARTH_RADIUS_KM`
    |
341 -     pub fn update_performance(&self, latency: f32, bandwidth: f32, packet_loss: f32) {
341 +     pub fn update_performance(&self, types::GeoPoint::distance_km::EARTH_RADIUS_KM: f32, bandwidth: f32, packet_l
oss: f32) {
    |

warning: unused variable: `bandwidth`
   --> src\comms\routing.rs:341:52
    |
341 |     pub fn update_performance(&self, latency: f32, bandwidth: f32, packet_loss: f32) {
    |                                                    ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
341 |     pub fn update_performance(&self, latency: f32, _bandwidth: f32, packet_loss: f32) {
    |                                                    +
help: you might have meant to pattern match on the similarly named constant `EARTH_RADIUS_KM`
    |
341 -     pub fn update_performance(&self, latency: f32, bandwidth: f32, packet_loss: f32) {
341 +     pub fn update_performance(&self, latency: f32, types::GeoPoint::distance_km::EARTH_RADIUS_KM: f32, packet_los
s: f32) {
    |

warning: unused variable: `packet_loss`
   --> src\comms\routing.rs:341:68
    |
341 |     pub fn update_performance(&self, latency: f32, bandwidth: f32, packet_loss: f32) {
    |                                                                    ^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
341 |     pub fn update_performance(&self, latency: f32, bandwidth: f32, _packet_loss: f32) {
    |                                                                    +
help: you might have meant to pattern match on the similarly named constant `EARTH_RADIUS_KM`
    |
341 -     pub fn update_performance(&self, latency: f32, bandwidth: f32, packet_loss: f32) {
341 +     pub fn update_performance(&self, latency: f32, bandwidth: f32, types::GeoPoint::distance_km::EARTH_RADIUS_KM:
 f32) {
    |

warning: unused variable: `ip_exposed`
   --> src\comms\routing.rs:348:43
    |
348 |     pub fn update_privacy_analysis(&self, ip_exposed: bool, resistance: f32) {
    |                                           ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: 
`_ip_exposed`

warning: unused variable: `resistance`
   --> src\comms\routing.rs:348:61
    |
348 |     pub fn update_privacy_analysis(&self, ip_exposed: bool, resistance: f32) {
    |                                                             ^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
348 |     pub fn update_privacy_analysis(&self, ip_exposed: bool, _resistance: f32) {
    |                                                             +
help: you might have meant to pattern match on the similarly named constant `EARTH_RADIUS_KM`
    |
348 -     pub fn update_privacy_analysis(&self, ip_exposed: bool, resistance: f32) {
348 +     pub fn update_privacy_analysis(&self, ip_exposed: bool, types::GeoPoint::distance_km::EARTH_RADIUS_KM: f32) {
    |

Some errors have detailed explanations: E0061, E0252, E0277, E0308, E0412, E0432, E0599.
For more information about an error, try `rustc --explain E0061`.
warning: `williw` (lib) generated 24 warnings
error: could not compile `williw` (lib) due to 23 previous errors; 24 warnings emitted
